## Bindings

Запуск каждого Flutter-приложения начинается с вызова функции [`runApp`](https://api.flutter.dev/flutter/widgets/runApp.html). Давайте посмотрим на её реализацию. 

```dart
void runApp(Widget app) {
  final WidgetsBinding binding = WidgetsFlutterBinding.ensureInitialized();
  assert(binding.debugCheckZone('runApp'));
  binding
    ..scheduleAttachRootWidget(binding.wrapWithDefaultView(app))
    ..scheduleWarmUpFrame();
}
```

В функции происходят три важных действия:

1. Получается и инициализируется, если необходимо, объект `binding` с типом `WidgetsBinding`.
2. Вызывается метод `scheduleAttachRootWidget`, в который передаётся переданный в функцию виджет.
3. Откладывается операция отрисовки первого кадра — `scheduleWarmUpFrame`.

Давайте сфокусируемся на первом действии и разберёмся, какую роль оно играет в запуске нашего приложения.

Bindings (сервисы связи) — это некоторые связующие классы, выполняющие роль «клея» между движком и фреймворком. А если говорить формальным языком — интерфейсы обмена данными между Flutter framework и Flutter engine. 

По правде говоря, это не чистая связь между кодом движка на C++ и Dart-кодом, а связь между [`PlatformDispatcher`](https://api.flutter.dev/flutter/dart-ui/PlatformDispatcher-class.html) из [dart:ui](https://api.flutter.dev/flutter/dart-ui/dart-ui-library.html) и более высокоуровневыми слоями фреймворка, своего рода набор [фасадов](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D1%81%D0%B0%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) над `PlatformDispatcher`.

Базовый класс для всех bindings — [`BindingBase`](https://api.flutter.dev/flutter/foundation/BindingBase-class.html). Конкретные сервисы наследуются от `BindingBase`. Они обязуются гарантировать единственность своего экземпляра и инициализируются только один раз (реализуют паттерн «[Синглтон](https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования))»). Каждый сервис отделяет в себе обработку ограниченного набора задач, связанных непосредственно с ним. В сервисе `GestureBinding`, например, обрабатываются задачи, связанные со взаимодействием пользователя с экраном устройства. 

Всего во Flutter девять наследников класса `BindingBase`:

- [`SchedulerBinding`](https://api.flutter.dev/flutter/scheduler/SchedulerBinding-mixin.html);
- [`ServicesBinding`](https://api.flutter.dev/flutter/services/ServicesBinding-mixin.html);
- [`GestureBinding`](https://api.flutter.dev/flutter/gestures/GestureBinding-mixin.html);
- [`RendererBinding`](https://api.flutter.dev/flutter/rendering/RendererBinding-mixin.html);
- [`SemanticsBinding`](https://api.flutter.dev/flutter/semantics/SemanticsBinding-mixin.html);
- [`PaintingBinding`](https://api.flutter.dev/flutter/painting/PaintingBinding-mixin.html);
- [`WidgetsBinding`](https://api.flutter.dev/flutter/widgets/WidgetsBinding-mixin.html);
- [`WidgetsFlutterBinding`](https://api.flutter.dev/flutter/widgets/WidgetsFlutterBinding-class.html);
- [`TestWidgetsFlutterBinding`](https://api.flutter.dev/flutter/flutter_test/TestWidgetsFlutterBinding-class.html).

Bindings связаны между собой определённой структурой: одни сервисы связи также являются миксинами над другими, более низкоуровневыми. Зависимости между ними можно представить следующей схемой:

![flt_2.2.svg](https://yastatic.net/s3/ml-handbook/admin/flt_2_2_1e49c1e906.svg)

Давайте взглянем на каждый сервис связи и его задачи подробнее.

### SchedulerBinding

Главная задача этого сервиса — планировка задач, связанных с отрисовкой кадра. Например: 

1. Вызовы преходящих задач (`transientCallbacks`), которые инициирует система в методе `Window.onBeginFrame`. Например, события тикеров и контроллеров анимации.
2. Не связанные с рендерингом задачи (`midFrameMicrotasks`), которые должны быть выполнены между кадрами. То есть микротаски, запланированные преходящими задачами. Это может быть очистка очереди событий обработанных жестов, обработка скролла. Микротаски выполняются между подготовкой к новому кадру и его отрисовкой.
3. Вызовы непрерывных задач (`persistentCallbacks`), которые инициирует система в методе `Window.onDrawFrame`. В частности, это вызов метода `build` у виджета или `layout` у рендер-объекта.
4. Задачи, вызываемые после отрисовки кадра (`postFrameCallbacks`). Обычно это задачи, которые не могут выполниться в процессе рендеринга, например отправка семантических событий (изменение фокуса) или очистка кеша изображений.

Одновременно `SchedulerBinding` может работать только с одним типом задач, обработка идёт в том порядке, в котором мы перечислили их выше.

Узнать, какую задачу в данный момент обрабатывает `SchedulerBinding`, можно с помощью геттера `schedulerPhase`, который возвращает состояние [`SchedulerPhase`](https://api.flutter.dev/flutter/scheduler/SchedulerPhase.html).

Далее поговорим о том, где будет полезен `SchedulerBinding` и его методы.

**addPostFrameCallback и endOfFrame**

Очень часто нам нужно выполнить код после окончания рендеринга текущего кадра, когда станут доступны размеры всех виджетов: например, чтобы получить размер виджета, который не известен заранее.

Для этого мы можем воспользоваться двумя способами — методом `addPostFrameCallback` или геттером `endOfFrame`. Вот так:

```dart
    void main() {
      for (int i = 0; i < 10; i++) {
        print('hello ${i + 1}');
      }
    }
```

Ещё один вариант использования `SchedulerBinding` — возможность наблюдать за метриками отрисовки вашего приложения.

**Наблюдение за производительностью**

С помощью `SchedulerBinding` вы можете наблюдать за производительностью вашего приложения, используя следующие методы:

```dart
// [FrameTiming] — объект с информацией о кадре
typedef TimingsCallback = void Function(List<FrameTiming> timings);

// Добавить [TimingsCallback]
void addTimingsCallback(TimingsCallback callback)

// Удалить [TimingsCallback]
void removeTimingsCallback(TimingsCallback callback)
```

Здесь `FrameTiming` — объект, который содержит метрики отрисовки кадра, такие как:

- длительность фазы build
- длительность фазы отрисовки на GPU

Эти метрики собираются в батчи и отправляются примерно раз в секунду в release-режиме сборки. Разработчики Flutter [утверждают](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/scheduler/binding.dart#L307), что за каждый зарегистрированный [`TimingsCallback`](https://api.flutter.dev/flutter/dart-ui/TimingsCallback.html) использование процессора вырастет примерно на 0,01%, — это замедляет перформанс приложения, и нужно пользоваться этим функционалом с осторожностью.

<p-important>

  Батч (англ. batch) — набор данных, собранный в группу. Это позволяет не отправлять данные часто и экономить ресурсы при их частой отправке.

</p-important>

Пример использования `TimingsCallback`:

```dart
    void main() {
      for (int i = 0; i < 10; i++) {
        print('hello ${i + 1}');
      }
    }
```

**Сборка мусора**

С помощью сервиса `SchedulerBinding` можно управлять стратегией работы сборщика мусора.

```dart
PerformanceModeRequestHandle? requestPerformanceMode(DartPerformanceMode mode)
```

Метод просит его перейти в определённый [`DartPerformanceMode`](https://api.flutter.dev/flutter/dart-ui/DartPerformanceMode.html). Существуют четыре режима работы:

- `balanced` — стандартный режим работы, идеально оптимизированный для Flutter;
- `latency` — снижение времени задержек за счёт увеличения накладных расходов на память; не рекомендуется находиться в этом режиме длительное время;
- `throughput` — увеличение пропускной способности за счёт увеличения задержек на обработку;
- `memory` — оптимизация для работы в условиях низкой доступной памяти, работает чаще с большим объёмом данных, что понижает перформанс.

На выходе вы получаете nullable-объект `PerformanceModeRequestHandle`, который используется для вывода из установленного `DartPerformanceMode`: нужно вызвать метод `dispose` для освобождения ресурсов. Если возвращается `null`, значит, в данный момент какой-то другой код запросил режим работы другого типа.

<p-important>

  Используйте `requestPerformanceMode` для оптимизации только в том случае, если проблемы производительности приложения возникают из-за сборщика мусора. Помните: это крайняя мера, если другие оптимизации не помогли. 

  И ещё один совет: всегда замеряйте метрики производительности до и после изменений. Подробнее о производительности приложения — в [параграфе Профилирование: Flutter DevTools](https://education.yandex.ru/handbook/flutter/article/profilirovanie-flutter-devtools).

</p-important>

### ServicesBinding

Вот за что он отвечает:

- Прослушивание и перенаправление платформенных сообщений в [`BinaryMessenger`](https://api.flutter.dev/flutter/services/BinaryMessenger-class.html), сервис, к которому по умолчанию привязываются платформенные каналы: каналы методов ([`MethodChannel`](https://api.flutter.dev/flutter/services/MethodChannel-class.html)) и событий ([`EventChannel`](https://api.flutter.dev/flutter/services/EventChannel-class.html)). При получении очередного сообщения `BinaryMessenger` перенаправляет его в соответствующий платформенный канал. `BinaryMessenger` умеет не только получать, но и отправлять сообщения в платформу. Подробнее о нём вы можете почитать в параграфе [Channels](https://academy.yandex.ru/handbook/flutter/article/channels).
- Сбор и регистрация лицензий пакетов, которые были в приложении в качестве зависимостей. Лицензии пакетов зашиваются в приложении во время его сборки инструментами Flutter.
- Сохранение ссылки на токен главного изолята. Он может использоваться, если необходимо общаться через платформенные каналы из сторонних изолятов. Подробнее об этом вы прочитаете в [параграфе Advanced изоляты и зоны, асинхронное и параллельное программирование](https://education.yandex.ru/handbook/flutter/article/advanced-izolyaty-i-zony-i-asinhronnoe-i-parallelnoe-programmirovanie).
- Обработка системных событий, которые идут от платформы. Например, запрос на выход из приложения, жизненный цикл приложения, событие out of memory, нажатия клавиатуры и др.
- Создание [`RestorationManager`](https://api.flutter.dev/flutter/services/RestorationManager-class.html) — это сущность, которая отвечает за восстановление состояния приложения. Про него подробно рассказывали в [лекции](https://www.youtube.com/watch?v=xManvu0z4mU&list=PLIh9yLdjK2YepDyvvvHR-_Iv_YD-W-gSP&index=4) про persistence Школы мобильной разработки Яндекса.

### GestureBinding

Главная обязанность сервиса `GestureBinding` — это обработка взаимодействия пользователя с экраном устройства, то есть обработка жестов.

Получаемые на вход данные о нажатиях доставляются конкретным потребителям этих событий (кнопки, области со скроллом и т. д.). Процесс распознавания адресата для события называется `hitTest`, результат распознавания — [`hitTestResult`](https://api.flutter.dev/flutter/gestures/HitTestResult-class.html). 

`GestureBinding` умеет кешировать `hitTestResult` для большей эффективности. Помимо обработки событий со стороны устройства, `GestureBinding` также открывает возможность посылать «ложные» события нажатий, что используется в `TestWidgetsFlutterBinding`.
Подробнее про `hitTest` вы можете прочитать в параграфе [RenderObject](https://academy.yandex.ru/handbook/flutter/article/renderobject).

### RendererBinding

Этот сервис — связующее между деревом RenderObject и Flutter engine. У него две основные обязанности:

- Прослушивание событий от engine для информирования об изменении настроек устройства, которые могут затрагивать семантический слой или как-то влиять на визуальное представление вашего приложения (например, тёмная тема или размер текста).
- Передача во Flutter engine изменений на экране с помощью Layer tree. Подробнее — в параграфе [RenderObject](https://academy.yandex.ru/handbook/flutter/article/renderobject).

Для того чтобы передавать изменения в engine, этот binding отвечает за управление [`PipelineOwner`](https://api.flutter.dev/flutter/rendering/PipelineOwner-class.html) и инициализацию [`RenderView`](https://api.flutter.dev/flutter/rendering/RenderView-class.html).

`PipelineOwner` — это такой объект, который знает, какой [`RenderObject`](https://api.flutter.dev/flutter/rendering/RenderObject-class.html) должен среагировать в ответ на изменения layout. Он же и управляет этой реакцией.

### SemanticsBinding

Связывает engine и слой семантики. Отвечает за всё необходимое для accessibility приложения, чтобы им могли пользоваться люди с ограниченными возможностями здоровья:

- упрощение или отключение анимации;
- управление обновлениями семантики и доставка этих событий в [`SemanticsNode`](https://api.flutter.dev/flutter/semantics/SemanticsNode-class.html), для этого используется [`SemanticsOwner`](https://api.flutter.dev/flutter/semantics/SemanticsOwner-class.html);
- обработка и доставка [`SemanticsAction`](https://api.flutter.dev/flutter/dart-ui/SemanticsAction-class.html) в нужный `SemanticsNode`.

Подробнее про accessibility вы можете прочитать в параграфе [Accessibility](https://education.yandex.ru/handbook/flutter/article/accessibility).

### PaintingBinding

Binding для связи с библиотекой painting, вот за что он отвечает:

- механизм кеширования и вытеснения из кеша (cache eviction) изображений;
- прогрев шейдеров (подробнее о том, зачем нужен прогрев шейдеров, можно почитать в параграфе [Профилирование](https://academy.yandex.ru/handbook/flutter/article/profilirovanie-flutter-devtools));
- уведомления об изменении шрифтов в системе и их предоставление;
- предоставление кодеков для декодирования изображений.

<p-important>

Вытеснение из кеша (cache eviction) — это процесс удаления данных из кеша компьютерной системы для освобождения места под новые данные. Кеш используется для временного хранения часто используемых данных и для быстрого доступа к ним. Однако кеш имеет ограниченный размер, и, когда он заполняется, новые данные не могут быть добавлены без удаления старых.

</p-important>

### WidgetsBinding

Связывает engine и виджеты. У него две основные задачи:

- управление процессом перестроения структуры дерева элементов (для этого используется [`BuildOwner`](https://api.flutter.dev/flutter/widgets/BuildOwner-class.html));
- вызов рендера в ответ на изменения структуры дерева.

Помимо этого, он объединяет функционал других сервисов связи и переадресовывает его в слушателей — виджеты с миксином [`WidgetsBindingObserver`](https://api.flutter.dev/flutter/widgets/WidgetsBindingObserver-class.html). Например, изменения состояния приложения [`AppLifeCycleState`](https://api.flutter.dev/flutter/dart-ui/AppLifecycleState.html), которые изначально попадают в `ServicesBinding`, перехватываются и отправляются в `WidgetsBindingObserver`. Для того чтобы наблюдать за платформенными событиями, вам нужно примиксовать `WidgetsBindingObserver` в свой виджет.

Пример:

```dart
    void main() {
      for (int i = 0; i < 10; i++) {
        print('hello ${i + 1}');
      }
    }
```

Обратите внимание, что в методе `dispose` вызывается `WidgetsBinding.instance.removeObserver(this)` для освобождения памяти.

С помощью такого механизма работает виджет [`MediaQuery`](https://api.flutter.dev/flutter/widgets/MediaQuery-class.html) — он наблюдает за событием `didChangeMetrics` и сообщает подписчикам `InheritedWidget` про обновление.

### WidgetsFlutterBinding

Этот сервис связи хоть и наследуется от `BindingBase`, но не отделяет в себе какую-то конкретную логику общения с engine. Его главная роль — инициализация всех сервисов связи, необходимых фреймворку для корректной работы.

### TestWidgetsFlutterBinding

Содержит функционал, полезный при написании интеграционных тестов. 

Используется библиотекой flutter_test. Как и `WidgetsFlutterBinding`, отвечает за инициализацию основных сервисов связи. Так же зависит от [`TestDefaultBinaryMessengerBinding`](https://api.flutter.dev/flutter/flutter_test/TestDefaultBinaryMessengerBinding-mixin.html), который переопределяет `defaultBinaryMessenger` на [`TestDefaultBinaryMessenger`](https://api.flutter.dev/flutter/flutter_test/TestDefaultBinaryMessenger-class.html). Он имеет доступ к данным, отправленным со стороны плагинов, что полезно для тестовых фреймворков, мониторинга и синхронизации с сообщениями платформы.

## Рендеринг и bindings

Давайте вспомним с вами несколько фактов об устройстве вёрстки во Flutter, о которых рассказывалось в параграфе [Elements](https://academy.yandex.ru/handbook/flutter/article/elements):

- виджет — неизменяемая конфигурация для [`Element`](https://api.flutter.dev/flutter/widgets/Element-class.html);
- из виджетов получается дерево элементов, элемент содержит ссылку на виджет, который его создал;
- элементы связаны друг с другом как parent и child;
- элемент может содержать `RenderObject`.

Для того чтобы обновить картинку на устройстве, `Element` и `RenderObject` в начале проходят фазу аннулирования.

<p-important>

Аннулирование (англ. invalidate) — это проверка, что элементы или рендер-объекты не устарели. Например, при получении новой конфигурации элемент может ей не соответствовать, и тогда требуется обновление дерева элементов.

</p-important>

Для `Element` этот процесс запускается в следующих двух сценариях:

1. Первый сценарий — в случае вызова метода `setState`: проверяется, не устарел ли [`StatefulElement`](https://api.flutter.dev/flutter/widgets/StatefulElement-class.html).
2. Второй сценарий — в случае, если `Element` подписан на [`ProxyElement`](https://api.flutter.dev/flutter/widgets/ProxyElement-class.html), который отправляет уведомление об изменении его конфигурации — `InheritedWidget`.

Результатом фазы аннулирования элементов является список элементов, помеченных флагом `dirty`.

Для `RenderObject` сценарии следующие:

1. Изменения геометрии `RenderObject` (позиция, размер и т. д.).
2. Необходимость перерисовки (если поменялся только цвет, стиль шрифта и т. д.).

В результате фазы аннулирования получается список `RenderObject`, который необходимо перерисовать.

После фазы аннулирования в ход вступает сервис`SchedulerBinding` и отправляет запрос в Flutter engine на планировку следующего кадра.

После того как engine будет готов отрисовать следующий кадр, он обращается к `SchedulerBinding` и вызывает метод `onDrawFrame`.

На схеме ниже показано, что происходит после получения `SchedulerBinding` сигнала `onDrawFrame` от engine:

![flt_2.2-1-14.svg](https://yastatic.net/s3/ml-handbook/admin/flt_2_2_1_14_fcf62d91b2.svg)

Scheduler делегирует вызов в сервис `WidgetsBinding`, вызывая метод `drawFrame`.

В первую очередь `WidgetsBinding` рассматривает изменения, произошедшие в дереве элементов: вызывает у`BuildOwner` метод `buildScope`, в котором проходится список элементов, помеченных как dirty. У каждого элемента вызывается метод `rebuild`, что, как правило, ведёт к вызову метода `build` и получению нового виджета. Далее есть два варианта поведения:

1. Если у элемента не инициализировано поле `child`, вызывается метод `inflate`, что ведёт к созданию нового элемента.
2. Если поле инициализировано, происходит проверка по ключу и типу: можно ли оставить существующий элемент (child). Если оставить можно, то элемент остаётся, если нет — он выбрасывается, вызывается `inflate` для получения нового элемента на место `child`.

После обработки элементов подходит очередь [рендер-объектов](https://academy.yandex.ru/handbook/flutter/article/renderobject), которые требуют перерисовки. Сервис `WidgetsBinding` по цепочке вызывает метод `drawFrame` у `RendererBinding`, и происходит следующее:

- у каждого `RenderObject`, помеченного dirty, вызывается метод `performLayout`, который считает геометрию объекта (размер, отступы и т. д.);
- происходит перерисовка `RenderObject`, у которого флаг `needsPaint` принимает значение true;
- полученная сцена отправляется в `RenderView` с помощью метода `compositeFrame`, затем эта сцена доставляется во Flutter engine для отрисовки;
- затем происходит обновление слоя семантики.

Наконец, новый кадр появляется на экране устройства.

![flt_2.2-2-13.svg](https://yastatic.net/s3/ml-handbook/admin/flt_2_2_2_13_301c68bfd3.svg)

Совместив весь процесс отрисовки кадра, получаем следующую схему:

![flt_2.2-3.svg](https://yastatic.net/s3/ml-handbook/admin/flt_2_2_3_e5e7be16a5.svg)

Знаем, было нелегко, но мы справились!

В этом параграфе мы узнали, что такое `Bindings` и как они связывают Flutter engine с Flutter framework. Изучили, какие бывают типы сервисов связи и какую функцию имеет каждый из них, а также познакомились с тем, какую роль они принимают в процессе рендеринга.

В следующем параграфе мы приступим к изучению сливеров (англ. slivers) — инструментов, с помощью которых можно делать интерактивные списки элементов и разнообразить функциональность интерфейса вашего приложения.