В Flutter-приложении нередко возникает ситуация, когда нужно обновить только небольшую часть экрана или необходимо анимировать движение неизменного объекта, для которого не требуется повторная отрисовка. Во всех этих случаях можно сберечь ресурсы графического процессора и использовать заранее построенное растровое изображение виджета. Эта возможность реализуется во Flutter посредством использования слоев, как в случае использования Skia, там и для Impeller. 

До того, как переходить к определению слоя, давайте вспомним как выглядит процесс отрисовки приложения на экране, для этого сделаем очень простое приложение с единственным корневым виджетом ColoredBox.

```dart
import 'package:flutter/material.dart';  
  
void main() {  
  runApp(RootWidget());  
}  
  
class RootWidget extends StatelessWidget {  
  @override  
  Widget build(BuildContext context) => const ColoredBox(color: Colors.green);  
}
```

При запуске приложения через `runApp` создается корневой `RenderObject` с типом `RenderView` и в него размещается `RenderObject` от `ColoredBox`, поскольку сам `RootWidget` является композиционным виджетом и не содержит `RenderObject`. Давайте проверим это, для этого добавим вывод дампа дерева `RenderObject` после завершения построения кадра:

```dart
class RootWidget extends StatelessWidget {  
  @override  
  Widget build(BuildContext context) {  
    SchedulerBinding.instance.addPostFrameCallback((_) {  
      debugDumpRenderTree();  
    });  
    return const ColoredBox(color: Colors.green);  
  }
}
```

Посмотрим на вывод этого кода (оставлены только наиболее важные строки):

```
_ReusableRenderView#771c8
 │ view size: Size(1080.0, 2337.0) (in physical pixels)
 │ device pixel ratio: 2.6 (physical pixels per logical pixel)
 └─child: _RenderColoredBox#613bc
     creator: ColoredBox ← RootWidget ← _FocusInheritedScope ←
```

Можно видеть, что `RenderView` (класс `_ReusableRenderView`) отвечает за преобразование логических пикселей в физические (в этом случае коэффициент равен 2.6), а `_RenderColoredBox` за заполнение экрана цветом. Но каким образом это передается в графический процессор? И на каком этапе появляются растеризированные слои? 

GPU в Skia и в Impeller работает с примитивными операциями, список которых хорошо известен по интерфейсу [Canvas](https://api.flutter.dev/flutter/dart-ui/Canvas-class.html), среди них например построение заполненного прямоугольника, а также поддерживает матричные преобразования (масштабирование, поворот, сдвиг и другие) и пиксельные фильтры. 

Давайте разберемся, как связаны между собой `RenderObject` и операции, которые поступают для отрисовки в GPU. Для этого будет полезно вспомнить, как в целом работает `dart:ui` и как можно реализовать приложения без использования виджетов. Рассмотрим и разберем код, использующий низкоуровневые возможности `dart:ui`

```dart
import 'dart:ui';  
  
void main() {  
  final view = PlatformDispatcher.instance.implicitView;  
  final builder = SceneBuilder();  
  final pictureRecorder = PictureRecorder();  
  final canvas = Canvas(pictureRecorder);  
  canvas.drawRect(  
      Offset.zero & view!.display.size,  
      Paint()  
        ..color = const Color(0xFFFF0000)  
        ..style = PaintingStyle.fill);  
  builder.addPicture(Offset.zero, pictureRecorder.endRecording());  
  view.render(builder.build());  
}
```

Передача последовательности действий выполняется в объекте `view` (экземпляр `FlutterView`), который содержит информацию об активном дисплее и поддерживает пересылку сообщений в GPU через вызов `view.render`. Сама последовательность операций представлена в сцене (интерфейс `Scene`, нативная реализация в Flutter Engine представлена в виде класса `_NativeScene`). Сцена создается в дополнительном объекте класса `SceneBuilder` (нативная реализация `_NativeSceneBuilder`), который поддерживает несколько действий:

| Операция                                        | Назначение                                                                                                                     |
| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| `pushTransform`                                 | применение матричного преобразования                                                                                           |
| `pushOffset`                                    | добавление операции смещения на указанное количество логических пикселей                                                       |
| `pushClipRect` и множество других Clip-операций | применение операции обрезки видимой части                                                                                      |
| `pushOpacity`                                   | добавление полупрозрачности                                                                                                    |
| `pushColorFilter`                               | применение фильтра смешивания цветов                                                                                           |
| `pushImageFilter`                               | применение растровой операции, требует предварительной растеризации                                                            |
| `pushBackdropFilter`                            | применение операции ко всей вложенной операции (например, размытия), использует предварительную растеризацию                   |
| `pushShaderMask`                                | смешивание растеризованного изображения и результата вычисления фрагментного шейдера                                           |
| `pop`                                           | завершение применения операции, добавленной через push                                                                         |
| `addRetained`                                   | добавление ранее сгенерированного (и кэшированного) изображения, принимает ссылку на объект EngineLayer                        |
| `addPerformanceOverlay`                         | добавление графика времени выполнения: UI - dart-часть кода, Raster: CPU во Flutter Engine до передачи в GPU                   |
| `addTexture`                                    | добавляет платформенную текстуру по идентификатору, может быть зарегистрирована и обновлена через embedder или в нативном коде |
| `addPlatformView`                               | добавляет обновляемое представление нативного view (View для Android, UIView для iOS) по зарегистрированному идентификатору    |
| `addPicture`                                    | добавляет растеризированное изображение                                                                                        |

Эти действия составляют единую последовательность операций, также известную как [Display List](https://github.com/flutter/engine/tree/main/display_list). Все операции `push`/`pop` как следует из названия, работают со стеком операций, однако на этом уровне понятие слоя не имеет смысла и сцена создается просто как последовательность операций, где операции add являются терминальными и добавляют содержание, на которое применяется созданный к этому моменту стек преобразований. Например, добавим смещение и цветовой фильтр к существующему изображению:

```dart
import 'dart:ui';  
  
void main() {  
  final view = PlatformDispatcher.instance.implicitView;  
  final builder = SceneBuilder();  
  final pictureRecorder = PictureRecorder();  
  final canvas = Canvas(pictureRecorder);  
  canvas.drawRect(  
      Offset.zero & view!.display.size / 2,  
      Paint()  
        ..color = const Color(0xFFFF0000)  
        ..style = PaintingStyle.fill);  
  final picture = pictureRecorder.endRecording();  
  //генерация матрицы 5x4 для преобразования исходного RGBA в инверсный  
  final invert = List.generate(  
      20,  
      (i) => (i % 5 == 4)  
          ? (i == 19)  
              ? 0.0  
              : 255.0       //значение прозрачности  
          : (i == 18)  
              ? 1.0  
              : (i % 5 == i ~/ 5)  
                  ? -1.0    //инверсия компонентов RGB  
                  : 0.0);  
  builder.pushColorFilter(ColorFilter.matrix(invert));  
  builder.pushOffset(128, 128);             //смещение для первого голубого прямоугольника  
  builder.addPicture(Offset.zero, picture); //голубой прямоугольник со смещением  
  builder.pop();                            //снимаем со стека смещение  
  builder.addPicture(Offset.zero, picture); //голубой прямоугольник без смещения  
  builder.pop();                            //снимаем со стека ColorFilter  
  builder.pushOffset(256, 256);             //смещение для красного прямоугольника  
  builder.addPicture(Offset.zero, picture); //красный прямоугольник со смещением  
  builder.pop();                            //снимаем смещение Offset(256,256)  
  view.render(builder.build());  
}
```

Результат будет таким:

![[Screenshot 2024-09-22 at 19.51.36.png]]

Обратите внимание, что для обработки визуального представления из Flutter-виджетов, создаваемого через соответствующие `RenderObject`, используется только одна операция `addPicture` (или операция `addRetained` в случае, если переиспользуется ранее построенное изображение слоя). Таким образом можно увидеть, что любые виджеты, включая изображения, `CustomPaint` и даже тексты представляются в виде растеризованного изображения, которое может быть кэшировано или использовано в пиксельных преобразованиях, например при применении фильтра размытия. 
Дополнительно доступно несколько специальных операций для генерируемого содержания:
- `setCheckerboardOffscreenLayers` - помечать шахматной сеткой слои, которые отрисовывается в памяти
- `setCheckerboardRasterCacheImages` - помечать переиспользованные из растрового кэша изображения шахматной сеткой
- `setRasterizerTracingThreshold` - установить порог записи подробной информации о композиции кадра

## Слои в RenderObject


Теперь рассмотрим как реализуется связь между `RenderObject` и операциями `FlutterView`. Здесь уже появляется абстракция слоя, которые можно разделить на четыре категории:
- **слой содержания** (`PictureLayer`, `TextureLayer`, `PlatformViewLayer`, `PerformanceOverlayLayer`) преобразуется непосредственно в изображение, не может содержать вложенных слоев;
- **слой преобразования** (`OffsetLayer` - смещение, `TransformLayer` - матричное преобразование, `Clip...Layer` - обрезка, `OpacityLayer` - полупрозрачность, `...FilterLayer` и `BackdropFilter` - пиксельные преобразования, `ShaderMaskLayer` - применение фрагментного шейдера) - может содержать вложенные слои, применяет на них пиксельное или матричное преобразование;
- слои для **зависимого изменения преобразований** - `LeaderLayer` и `FollowerLayer`
- **слой метаданных** - `AnnotatedRegionLayer`, применяется для маркировки системных областей (например, области уведомлений), но также могут применяться для пометки фрагментов экрана и дальшейшего поиска через `findAnnotations<S>`

Все слои, кроме слоев содержания, являются контейнерами и могут содержать дочерние слои, что в конечном счете представляется в виде дерева слоев, которое преобразуется в последовательность операций в сцене на этапе выполнения `Compositor`. Слои могут перемещаться в пределах дерева. На каждом кадре дерево обрабатывается целиком (здесь нет понятия dirty, как в случае с деревом элементов), но часть слоев может быть переиспользована через применение `addRetained`. Переиспользование кэша будет выполняться автоматически, но можно его отключить через переопределение get-метода для `alwaysNeedsAddToScene` или вызов метода `markNeedsAddToScene` для слоя на этапе выполнения метода paint.

В приложении на Flutter корневой `RenderObject` представляется классом `RenderView`, который создает слой `TransformLayer` для всего приложения, в который уже добавляются дочерние слои.

Для любого `RenderObject` есть связанный с ним `debugLayer`, но не каждый `RenderObject` создает свой собственный слой. Это помогает оптимизировать использование памяти, поскольку каждый слой растеризуется независимо, увеличивая расход памяти. Однако побочным эффектом от совместного использования слоев становится необходимость повторной растеризации при изменении любого из связанных со слоем `RenderObject`.

Рассмотрим работу со слоями на конкретных примерах. Для этого создадим дерево RenderObject без использования фреймворка:

```dart
import 'dart:ui';  
  
import 'package:flutter/cupertino.dart';  
import 'package:flutter/rendering.dart';  
import 'package:flutter/scheduler.dart';  
  
void main() {  
  // инициализация связи Binding и Flutter Engine  
  WidgetsFlutterBinding.ensureInitialized();  
  // получение основного view (поверхность для рисования)  
  final view = PlatformDispatcher.instance.implicitView!;  
  // создание корневого RenderObject (RenderView)
  final renderView = RenderView(view: view, configuration: ViewConfiguration(  
    devicePixelRatio: view.devicePixelRatio,  
    physicalConstraints: BoxConstraints.fromViewConstraints(  
        view.physicalConstraints),  
    logicalConstraints: BoxConstraints.fromViewConstraints(  
        view.physicalConstraints / view.devicePixelRatio),  
  ));  
  // связывание RenderView и экземпляра RendererBinding  
  final rendererBinding = RendererBinding.instance;  
  rendererBinding.addRenderView(renderView);  
  renderView.attach(rendererBinding.rootPipelineOwner);  
  
  // подготовка первого кадра  
  renderView.prepareInitialFrame();  
  rendererBinding.scheduleWarmUpFrame();  
  SchedulerBinding.instance.addPostFrameCallback((_) {  
    // вывод связанного с RenderView слоя  
    print(renderView.debugLayer);  
  });
}
```

Здесь мы можем увидеть, что `RenderView` создает слой и его реализацию во Flutter Engine (`TransformEngineLayer`)

```
TransformLayer#a6db6(owner: RenderView#b6c9d, engine layer: TransformEngineLayer#f56b4, handles: 1, offset: Offset(0.0, 0.0), transform: [2.6,0.0,0.0,0.0; 0.0,2.6,0.0,0.0; 0.0,0.0,1.0,0.0; 0.0,0.0,0.0,1.0])
```

Также мы могли использовать `RenderView` непосредственно для создания сцены, через вызов метода `buildScene` (принимает экземпляр `builder`).

Добавим теперь дополнительный `RenderObject` для отображения заполнения экрана сплошным цветом. Поскольку реализация `RenderObject` для `ColoredBox` является приватным (`_RenderColoredBox`), выполним собственную реализацию в своем коде (более подробно про методы `RenderObject` можно прочитать в этом [link] параграфе):

```dart
class ColoredRenderBox extends RenderBox {  
  @override  
  void performLayout() => size = constraints.biggest/2;  
  
  @override  
  void paint(PaintingContext context, Offset offset) {  
    context.canvas.drawRect(  
        offset & size,  
        Paint()  
          ..color = const Color(0xFFFF0000)  
          ..style = PaintingStyle.fill);  
    super.paint(context, offset);  
  }  
}
```

и добавим новый `RenderObject` в наше самодельное дерево:

```dart
void main() {  
  // инициализация связи Binding и Flutter Engine  
  WidgetsFlutterBinding.ensureInitialized();  
  // получение основного view (поверхность для рисования)  
  final view = PlatformDispatcher.instance.implicitView!;  
  // создание корневого RenderObject (RenderView) и ColoredRenderBox  
  final renderView = RenderView(  
    child: ColoredRenderBox(),  
    view: view,  
  );  
  // связывание RenderView и экземпляра RendererBinding  
  final rendererBinding = RendererBinding.instance;  
  rendererBinding.addRenderView(renderView);  
  renderView.attach(rendererBinding.rootPipelineOwner);  
  renderView.configuration = ViewConfiguration(  
    devicePixelRatio: view.devicePixelRatio,  
    physicalConstraints: BoxConstraints.fromViewConstraints(view.physicalConstraints).loosen(),  
    logicalConstraints: BoxConstraints.fromViewConstraints(  
            view.physicalConstraints / view.devicePixelRatio)  
        .loosen(),  
  );
  // здесь для logincalConstraints установлено минимальный размер (0,0)
  // через вызов loosen, чтобы можно было сделать прямоугольник,
  // с размером меньше, чем размер экрана
  // подготовка первого кадра (первоначальный layout - paint)  
  renderView.prepareInitialFrame();  
  rendererBinding.scheduleWarmUpFrame();  
  
  SchedulerBinding.instance.addPostFrameCallback((_) {  
    // вывод связанного с RenderView слоя  
    debugDumpLayerTree();  
  });
}
```

Здесь можно увидеть, что в метод `paint` передается не `Canvas`, как это можно было бы ожидать для метода создания виджета из графических примитивов, а `PaintingContext`. Это связано с необходимостью поддержки слоев, но сейчас пока ограничимся, что из свойства `canvas` в `PaintingContext` можно получить `Canvas`, связанный с текущим слоем.При запуске увидим, что теперь в нашем дереве слоев есть два слоя, которые легко соотносятся с операциями построения сцены:

```
TransformLayer#13ddf
  owner: RenderView#10678
  creator: RenderView
  engine layer: TransformEngineLayer#7bfd9
  offset: Offset(0.0, 0.0)
  child 1: PictureLayer#b6f86
    handles: 1 
    paint bounds: Rect.fromLTRB(0.0, 0.0, 540.0, 1168.5)
    picture: _NativePicture#ed451
    raster cache hints: isComplex = false, willChange = false
```

Эти два слоя могут быть преобразованы в последовательность операций: `pushTransform`, `addPicture`, `pop`. Размер слоя изображения определяется по размеру `RenderObject` (из поля `size` после `performLayout`) и это помогает минимизировать использование памяти (изображение будет кэшировано после первого создания, флаг `isComplex` позволяет отключить кэширование, а `willChange` запросить обновление на следующем кадре). Основная проблема такого подхода в том, что при добавлении нескольких `RenderObject`, они все будут переиспользовать один и тот же слой `PictureLayer`. Давайте это проверим, для этого будем использовать `RenderObject` для виджета `Stack` - `RenderStack`. Добавим поддержку смещения и цвета в `ColoredRenderObject`:

```dart
class ColoredRenderBox extends RenderBox {  
  Color color;  
  Offset shift;  
  
  ColoredRenderBox({  
    required this.color,  
    required this.shift,  
  });  
  
  @override  
  void performLayout() => size = constraints.biggest / 2;  
  
  @override  
  void paint(PaintingContext context, Offset offset) {  
    context.canvas.drawRect(  
        (offset + shift) & size,  
        Paint()  
          ..color = color  
          ..style = PaintingStyle.fill);  
    super.paint(context, offset);  
  }  
}
```

И изменим определение дерева RenderObject:

```dart
final firstRenderBox = ColoredRenderBox(  
  color: const Color(0xFFFF00FF),  
  shift: Offset.zero,  
);  
final secondRenderBox = ColoredRenderBox(  
  color: const Color(0xFFFF0000),  
  shift: const Offset(32, 32),  
);  
final renderView = RenderView(  
  view: view,  
  child: RenderStack(  
    children: [  
      firstRenderBox,  
      secondRenderBox,  
    ],  
    textDirection: TextDirection.ltr,  
  ),  
);
```

Результат выполнения будет таким:

![[Screenshot 2024-09-22 at 23.15.46 1.png]]

Однако если мы посмотрим на дерево слоев, то обнаружим, что дерево не изменилось и оба прямоугольника находятся в одном слое `PictureLayer` и, как следствие, при изменении свойств любого из них будет необходимо создать растровое изображение для обоих `RenderObject`. Чтобы этого избежать нужно использовать встроенный механизм создания отдельного слоя для `RenderObject`, который реализуется через переопределение getter для `isRepaintBoundary`. Добавим следующий код в определение `ColoredRenderObject`:

```
@override  
bool get isRepaintBoundary => true;
```
Теперь в дереве слоев будет следующая иерархия:
```
TransformLayer
  - OffsetLayer
    - PictureLayer
  - OffsetLayer
    - PictureLayer
```

Каждый `OffsetLayer` кэшируется независимо и может переиспользоваться на следующих кадрах. 

Теперь изменим свойства одного из `RenderObject` и запросим повторное перестроение кадра, для этого добавим следующий фрагмент кода после вызова `scheduleWarmUpFrame`:

```dart
PlatformDispatcher.instance.onPointerDataPacket = (pointer) {  
  if (pointer.data.first.change == PointerChange.down) {  
    firstRenderBox.color = const Color(0xFF00FFFF);  
    firstRenderBox.markNeedsPaint();  
    rendererBinding.scheduleFrame();  
    SchedulerBinding.instance.addPostFrameCallback((_) {  
      // вывод связанного с RenderView слоя  
      debugDumpLayerTree();  
    });  
  }  
};
```

Если сравнить исходное дерево слоев и дерево после обновления, то можно обнаружить что слои `TransformLayer` и `OffsetLayer`-`PictureLayer` для второго `RenderObject` не изменяются, а для первого создаются новые. Таким образом, изображение из `PictureLayer` для второго (красного) прямоугольника извлекается из растрового кэша. При изменении свойств слоя, например последовательности операций на canvas, в `PictureLayer` вызывается метод `markNeedsAddToScene` для пересоздания растрового представления слоя, иначе бы вместо `addPicture` в последовательности операций передавался бы `addRetained`.

Второй способ изоляции содержания - использование стека операций в `PaintingContext`. Операции `push` в `PaintingContext` позволяют добавить дополнительные слои преобразования и создать новый контекст для связывания `canvas` с вложенным `PictureLayer`. Например, мы можем добавить операцию `pushOpacity` для отображения полупрозрачного прямоугольника:

```dart
class ColoredRenderBox extends RenderBox {  
  Color color;  
  Offset shift;
  int opacity;
  
  @override  
  bool get isRepaintBoundary => true;  
  
  ColoredRenderBox({  
    required this.color,  
    required this.shift,
    required this.opacity,
  });  
  
  @override  
  void performLayout() => size = constraints.biggest / 2;  
  
  @override  
  void paint(PaintingContext context, Offset offset) {  
    context.pushOpacity(  
      Offset.zero,
      opacity,
      (context, offset) {  
        context.canvas.drawRect(  
            (offset + shift) & size,  
            Paint()  
              ..color = color  
              ..style = PaintingStyle.fill);  
      },  
    );  
  }  
}
```

Теперь дерево слоев будет таким:

```
TransformLayer < RenderView
- OffsetLayer < ColoredRenderBox
  - OpacityLayer
    - Picture Layer
- OffsetLayer < ColoredRenderBox
  - OpacityLayer
    - Picture Layer
```

Любой из контейнерных слоев, а также слоев содержания может быть преобразован в растровое изображение (методы `toImage` для асинхронного преобразования, которое будет завершено после выполнения растеризации, `toImageSync` - для синхронного извлечения текущего состояния растеризации).  Проверить возможность преобразования слоя в растровое изображение можно через вызов метода `supportsRasterization()`. Например, можно получить растеризованное изображение второго прямоугольника следующей операцией:

```dart
final layer = secondRenderBox.debugLayer!;  
if (layer.supportsRasterization()) {  
  final image = (layer as OffsetLayer).toImageSync(Offset.zero & secondRenderBox.size);  
}
```

Полученное изображение может быть повторно использовано в другой части иерархии. Создадим слой вручную и заполним его ссылкой на уже сформированное изображение из `PictureLayer`:

```dart
class ClonedRenderBox extends RenderBox {  
  Picture picture;  
  
  ClonedRenderBox({required this.picture});  
  
  @override  
  void performLayout() => size = constraints.biggest;  
  
  @override  
  void paint(PaintingContext context, Offset offset) {  
    final pictureLayer = PictureLayer(offset & size);  
    context.addLayer(pictureLayer);  
    pictureLayer.picture = picture;  //программное переопределение содержимого слоя
  }  
}
```

Теперь мы можем добавить этот RenderBox и заполнить его изображением из PictureLayer:

```dart
final renderStack = renderView.child as RenderStack;  
final pictureLayer = ((secondRenderBox.debugLayer as OffsetLayer)  
        .firstChild as OpacityLayer)  
    .firstChild as PictureLayer;  
renderStack.add(ClonedRenderBox(picture: pictureLayer.picture!));  
renderStack.markNeedsPaint();
```

Между слоями может выполняться передача данных с использованием аннотаций, которые определяются через `AnnotatedRegionLayer()` или виджет `AnnotatedRegion` с сохранением типизированных данных, которые могут быть извлечены из слоев, находящихся выше по иерархии, через вызов `findAnnotations<T>()` (заполняет список) и `find<T>` (возвращает найденный объект с данными указанного типа или `null`). Аннотация относится к набору пикселей в границах слоя.

## Слои и PaintingContext

`PaintingContext` является одной из реализаций `ClipContext`. `ClipContext` предоставляет методы для обрезки произвольного слоя: 
- `clipPathAndPaint` - отрисовка слоя и обрезка по произвольному пути 
- `clipRRectAndPaint` - отрисовка и обрезка по границам скругленному прямоугольнику
- `clipRectAndPaint` - отрисовка и обрезка по прямоугольнику.

`PaintingContext` создается на основе контейнерного слоя, например, присоединенной поверхности для рисования на мобильном устройстве или веб-браузере, и ожидаемого размера слоя - может быть размером экрана в логических пикселях. Для приложения в целом этим слоем становится `TransformLayer`, созданный в `RenderView`.

Для визуализации `RenderObject` используется метод `paintChild`, который выполняет  отрисовку дочернего `RenderObject` с указанным смещением. Каждый создаваемый `RenderObject` получает собственный `PaintingContext` на основе родительского слоя.

В зависимости от флага `isRepaintBoundary` в этом случае либо создается новый слой содержания (если `true`) или передается текущий `paintingContext` и `RenderObject` создается непосредственно в текущем слое. Изображение создается на `PictureLayer`, который встраивается внутрь контейнерного слоя `OffsetLayer` на основе `Canvas` + `PictureRecorder`. Использование canvas не отличается от рассмотренного ранее в параграфе про `CustomPaint` [ссылка на параграф].

Для RenderObject можно создать иерархию слоев любой сложности с использованием методов `PaintingContext` для добавления слоев (`push`), callback-метод которого получает новый контекст, привязанный к собственному слою. Кроме специализированных методов (`pushOpacity`, `pushClipRect`, ...) существует обобщенный метод `pushLayer`, который может использоваться для добавления слоев:

| Тип слоя                        | Назначение                                                                                                                                                                                                                     | Примечание                                                                                                                                                                                                                                     |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `PictureLayer`                  | Изображение слоя, используется совместно с `OffsetLayer`. Поддерживает кэширование и переиспользование ранее созданного изображения                                                                                            | Используется как поверхность для рисования и на его основе, через создание `PictureRecorder,` формируется `Canvas`. Если `isRepaintBoundary` в `RenderObject` возвращает false, используется `PictureLayer`, который был создан выше по дереву |
| `TextureLayer`                  | Слой для отображения текстуры, полученной от нативной платформы                                                                                                                                                                | Определяется по `int`-идентификатору                                                                                                                                                                                                           |
| `PlatformViewLayer`             | Слой для отображения платформенного компонента                                                                                                                                                                                 | Определяется по `int`-идентификатору `viewId`                                                                                                                                                                                                  |
| `PerformanceOverlayLayer`       | Слой для графика времени отрисовки кадра (UI / Raster Task Runner)                                                                                                                                                             | Используется при добавлении флага `showPerformanceOverlay: true` в `WidgetsApp`                                                                                                                                                                |
| `OffsetLayer`                   | Определяет сдвиг отображаемого на слое содержимого на указанное смещение (этот и последующие слои являются контейнерами `ContainerLayer` и могут содержать другие слои)                                                        | Дополнительно добавляет возможность создания снимка изображения слоя в список байтов `UInt8List` или кодирования в JPEG/PNG, создается в виджете `RepaintBoundary` и с любым `RenderObject` с `isRepaintBoundary ⇒ true`                       |
| `TransformLayer`                | Применение матричного преобразования для содержимого                                                                                                                                                                           | Использует `Matrix4` из пакета `vector_math_64`, применяется в виджете `Transform`                                                                                                                                                             |
| `ClipRectLayer`                 | Обрезка по границе прямоугольника                                                                                                                                                                                              | Также может использоваться `pushClipRect` и виджет `ClipRect`                                                                                                                                                                                  |
| `ClipRRectLayer`                | Обрезка по границе скругленного прямоугольника                                                                                                                                                                                 | Также `pushClipRRect` и виджет `ClipRRect`                                                                                                                                                                                                     |
| `ClipPathLayer`                 | Обрезка по произвольному пути                                                                                                                                                                                                  | Также `pushClipPath` и виджет `ClipPath`                                                                                                                                                                                                       |
| `ColorFilterLayer`              | Применение цветового фильтра к растровому изображению слоя                                                                                                                                                                     | Также `pushColorFilter`, используется в виджете `ColorFiltered`                                                                                                                                                                                |
| `ImageFilterLayer`              | Применение фильтра к изображению, размещенному через RawImage или полученному через растеризацию                                                                                                                               | Также `pushImageFilter` и виджет `ImageFiltered`                                                                                                                                                                                               |
| `ShaderMaskLayer`               | Использование шейдера и смешивания цветов над растровым изображением слоя                                                                                                                                                      | Также `pushShaderMask` и виджет `ShaderMask`                                                                                                                                                                                                   |
| `BackdropFilterLayer`           | Применение пиксельного фильтра к растровому изображению слоя, например `Blur`                                                                                                                                                  | Также `pushBackdropFilter` и виджет `BackdropFilter`                                                                                                                                                                                           |
| `OpacityLayer`                  | Добавление полупрозрачности к растровому изображению слоя                                                                                                                                                                      | Также `pushOpacity` и виджет `Opacity` → `RenderOpacity`                                                                                                                                                                                       |
| `LeaderLayer` / `FollowerLayer` | Управляющий и управляемый слой, первый накапливает примененные трансформации в матричное преобразование, второй связывается с первым, отслеживает изменение преобразований и применяет его ко всем размещенным на нем объектам | Используется в составных виджетах, расположение которых зависит от положения другого виджета (например, `AutoComplete` или `Slider`), создается в виджетах `CompositedTransformTarget` и `CompositedTransformFollower`                         |
| `AnnotatedRegionLayer`          | Добавление слоя с произвольными данными                                                                                                                                                                                        | Данные могут быть извлечены из любого слоя выше в иерархии через `Layer.find` по типу содержания. Тут важно отметить, что поиск происходит через полный обход дерева слоев и потенциально может занять долгое время.                           |

Также можно добавить существующий слой через addLayer, но нужно иметь ввиду, что каждый слой может использоваться в дереве только однократно. Если нужно сделать копию слоя, можно использовать следующий алгоритм:
- выполнить растеризацию существующего слоя
- создать новый PictureLayer
- добавить его в дерево слоев через addLayer

Аналогично можно программно создать слой для рисования через canvas:

```
final _screenshotCurrentLayer = PictureLayer(estimatedBounds);
final _screenshotRecorder = ui.PictureRecorder();
final _screenshotCanvas = Canvas(_screenshotRecorder!);
addLayer(_screenshotCurrentLayer!);
```

`PaintingContext` может быть создан полностью в памяти, для этого в него передается корневой контейнерный слой (например, `OffsetLayer`), который может накапливать другие слои. 

```dart
final rect = Offset.zero & const Size(64, 64);
final OffsetLayer offsetLayer = OffsetLayer();
final PaintingContext context = PaintingContext(offsetLayer, rect);
context.canvas.drawRect(
    rect,
    Paint()
      ..style = PaintingStyle.fill
      ..color = Colors.green);
final image = offsetLayer.toImageSync(rect);
print(image.width);
print(image.height);
```

Также доступ к PaintingContext есть в любом `RenderObject` (экземпляр объекта передается в метод `paint`). Важно отметить, что несмотря на указанные границы, слой всегда занимает всю отображаемую поверхность и в paint отрисовка может происходить даже за пределами указанного прямоугольника, в том числе с использованием отрицательных координат. Чтобы этого избежать можно использовать дополнительный clip-слой, который применяется к своему поддереву и ограничивает видимые изменения границей зоны обрезки (все остальные пиксели остаются прозрачными). Также нет никаких ограничений на количество слоев, добавляемых внутри paint, при этом если среди них есть `OffsetLayer`, он будет использоваться для нового `PaintingContext` при вызове `paintChild`. В противном случае дочерний RenderObject будет изображаться в пределах того же слоя, что и родительский.

## Примеры

Для тестирования будет использовать изображение ниже — для исключения проблемы с CORS для DartPad изображение добавлено в код в виде base64-строки:

![[sunset.jpg]]

Для отладки слоёв можно использовать функцию `debugDumpLayerTree()` из пакета `flutter/rendering.dart`. Добавим к первому примеру с простым деревом вывод списка слоёв в консоль при нажатии на кнопку:

[https://dartpad.dev/?id=8cade11c1a616642e0bbcea28b8706aa](https://dartpad.dev/?id=8cade11c1a616642e0bbcea28b8706aa)

Посмотрим на результаты вывода:

- `TransformLayer` (владелец — `RenderView`) — основной экран с трансформацией масштабирования для преобразования координат в пиксели на экране, например при hidpi разрешениях
    - `OffsetLayer` — `RepaintBoundary` из `MaterialApp` в `FocusScope`
        - `OffsetLayer`, владелец `RepaintBoundary` — `OffsetLayer` — `RepaintBoundary` из MaterialApp вокруг builder-функции для home
            - `PictureLayer` — изображение нашей сцены, вся `Column` вместе с растровым изображением и кнопкой

Таким образом, при появлении splash-эффекта над кнопкой одновременно с этим перерисовывается и изображение заката над морем. Чтобы этого избежать, добавим `RepaintBoundary` вокруг кнопки.

[https://dartpad.dev/?id=a5cd5a5a76b95d762d64497206376f5e](https://dartpad.dev/?id=a5cd5a5a76b95d762d64497206376f5e)

В дереве слоев появится дополнительная ветка, а растровое изображение теперь будет кэшироваться:

- `TransformLayer`
    - `OffsetLayer` — `RepaintBoundary` из `MaterialApp` в `FocusScope`
        - `OffsetLayer` — `RepaintBoundary` из `MaterialApp` вокруг builder-функции для home
            - `PictureLayer` — изображение заката
            - `OffsetLayer` — `RepaintBoundary`
                - `PictureLayer` — изображение кнопки

Аналогично при добавлении ряда виджетов будут создаваться промежуточные слои, например можно добавить размытие и полупрозрачность:

[https://dartpad.dev/?id=ead20d9587a4a99707b9f412eb6c9887](https://dartpad.dev/?id=ead20d9587a4a99707b9f412eb6c9887)

Дерево слоев:

- `TransformLayer`
    - `OffsetLayer` — `RepaintBoundary`
        - `OffsetLayer` — `RepaintBoundary`
            - `PictureLayer` — белая подложка
            - `OpacityLayer` — полупрозрачность
                - `ImageFilterLayer` — размытие
                    - `PictureLayer` — изображение заката
            - `OffsetLayer` — `RepaintBoundary`
                - `PictureLayer` — кнопка

Для доступа к `RenderObject`, соответствующему текущему элементу (`BuildContext`), можно использовать метод `findRenderObject` (может вернуть `null`, если к элементу не был присоединен `RenderObject`) или использовать глобальный ключ:

[https://dartpad.dev/?id=37ab467c23369a2e60fac5d00468254c](https://dartpad.dev/?id=37ab467c23369a2e60fac5d00468254c)

Понимание механизма работы слоев в GPU помогает создавать оптимизированные приложения, сохранять растеризированное представление виджетов, а также создавать сложные комбинации слоев в памяти для дальнейшего размещения их на сцене через `PictureLayer`. Создавать собственные типы слоев, к сожалению нельзя, поскольку они напрямую транслируются в соответствующие методы Flutter Engine (https://github.com/flutter/engine/tree/main/flow/layers). Кто заинтересован в более глубоком изучении принципов кэширования и работы со слоями, можете посмотреть в исходные тексты:
- https://github.com/flutter/engine/blob/main/flow/raster_cache.cc
- https://github.com/flutter/engine/blob/main/flow/compositor_context.cc
- https://github.com/flutter/engine/blob/main/flow/embedded_views.cc 
и поизучать метрики на Timeline в DevTools, куда отправляются следующие значения (от провайдера flutter, тип сообщения RasterCache):
- `LayerCount` - количество слоев
- `LayerMBytes` - объем слоев в памяти
- `PictureCount` - количество кэшированных изображений
- `PictureMBytes` - объем кэшированных изображений в памяти
Эти данные также используются для построения графика использования памяти в Memory View в DevTools.

